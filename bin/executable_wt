#!/usr/bin/env zsh

# Git worktree management tool
# Usage: wt <command> [options]

# Script version
VERSION="3.0.0"

# Default values
DEFAULT_BASE_BRANCH="main"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Function to print colored output
print_color() {
    local color=$1
    shift
    echo -e "${color}$@${NC}"
}

# Function to print to stderr (for messages that shouldn't interfere with shell integration)
print_err() {
    echo -e "$@" >&2
}

# Function to show usage
show_usage() {
    cat << EOF
wt - Git worktree management tool v${VERSION}

Usage: wt <command> [options]
       wt <branch-name> [base-branch]    # Shorthand for 'wt new'

Commands:
    new <branch> [base]     Create a new worktree (default command)
    switch [branch]         Switch to a worktree (use with shell integration)
    remove <branch>         Remove a worktree and optionally its branch
    list                    List all worktrees with status

Options for 'new':
    --pr <number>       Create worktree from GitHub PR (requires gh CLI)
    --no-copy           Don't copy any files to the worktree
    --no-symlink        Copy instead of symlinking editor configs
    --cursor            Open in Cursor editor

Options for 'remove':
    --force             Skip confirmation prompt
    --keep-branch       Don't delete the local branch
    --delete-remote     Also delete the remote branch

General Options:
    -h, --help          Show this help message
    -v, --version       Show version
    --shell-init        Output shell integration code

Examples:
    wt new feature-branch                # Create worktree from main
    wt OCT-12345-new-feature            # Shorthand for 'wt new'
    wt switch                            # Interactive worktree picker (requires fzf)
    wt switch feature                    # Switch to worktree (partial match)
    wt remove old-feature                # Remove worktree and branch
    wt remove old-feature --delete-remote  # Also delete remote branch
    wt list                              # List all worktrees

Shell Integration:
    Add to your ~/.zshrc:
        eval "\$(wt --shell-init)"

    This enables 'wt switch' to change your current directory.

Configuration:
    Project config: .wtconfig in git root
    User config: ~/.wtconfig

    Config file format (YAML):
    copy_files:
      - .env
      - .env.local
    copy_dirs:
      - .cursor
      - .vscode

Note: Editor configs are symlinked by default. Use --no-symlink to copy.
EOF
}

# Output shell integration code
shell_init() {
    cat << 'SHELL_INIT'
# wt shell integration
wt() {
    if [[ "$1" == "switch" ]]; then
        local result
        result=$(__wt_bin "$@")
        local exit_code=$?
        if [[ $exit_code -eq 0 && "$result" =~ ^__WT_CD__:(.+)$ ]]; then
            cd "${match[1]}"
        elif [[ -n "$result" ]]; then
            echo "$result"
        fi
        return $exit_code
    else
        __wt_bin "$@"
    fi
}

# Store the actual binary path
__wt_bin() {
    command wt "$@"
}
SHELL_INIT
}

# Function to parse YAML config file (simple implementation)
parse_config() {
    local config_file=$1
    local section=""

    if [[ ! -f "$config_file" ]]; then
        return
    fi

    while IFS= read -r line; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # Check for section headers
        if [[ "$line" =~ ^copy_files:[[:space:]]*$ ]]; then
            section="files"
        elif [[ "$line" =~ ^copy_dirs:[[:space:]]*$ ]]; then
            section="dirs"
        elif [[ "$line" =~ ^[[:space:]]*-[[:space:]](.+) ]]; then
            # Extract item after "- "
            local item="${match[1]}"
            if [[ "$section" == "files" ]]; then
                CONFIG_COPY_FILES+=("$item")
            elif [[ "$section" == "dirs" ]]; then
                CONFIG_COPY_DIRS+=("$item")
            fi
        else
            # Reset section if we hit a non-list line
            section=""
        fi
    done < "$config_file"
}

# Function to get files to copy based on priority
get_files_to_copy() {
    local -a files=()
    local -a dirs=()

    # 1. Built-in defaults - expanded to include more common files
    local default_files=(.env .env.local .env.development .env.production .env.test .mise.toml .envrc)
    local default_dirs=(.claude .vscode .cursor .idea .fleet .zed .nova .sublime .devcontainer config/credentials)

    # Add defaults if they exist
    for f in "${default_files[@]}"; do
        [[ -f "$project_dir/$f" ]] && files+=("$f")
    done

    for d in "${default_dirs[@]}"; do
        [[ "$d" != ".git" && -d "$project_dir/$d" ]] && dirs+=("$d")
    done

    # 2. Project config
    local project_config="$project_dir/.wtconfig"
    if [[ -f "$project_config" ]]; then
        local CONFIG_COPY_FILES=()
        local CONFIG_COPY_DIRS=()
        parse_config "$project_config"
        files+=("${CONFIG_COPY_FILES[@]}")
        for d in "${CONFIG_COPY_DIRS[@]}"; do
            [[ "$d" != ".git" ]] && dirs+=("$d")
        done
    fi

    # 3. User config
    local user_config="$HOME/.wtconfig"
    if [[ -f "$user_config" ]]; then
        local CONFIG_COPY_FILES=()
        local CONFIG_COPY_DIRS=()
        parse_config "$user_config"
        files+=("${CONFIG_COPY_FILES[@]}")
        for d in "${CONFIG_COPY_DIRS[@]}"; do
            [[ "$d" != ".git" ]] && dirs+=("$d")
        done
    fi

    # Remove duplicates
    local -A seen_files seen_dirs
    local unique_files=() unique_dirs=()

    for f in "${files[@]}"; do
        if [[ -z "${seen_files[$f]}" ]]; then
            seen_files[$f]=1
            unique_files+=("$f")
        fi
    done

    for d in "${dirs[@]}"; do
        if [[ -z "${seen_dirs[$d]}" && "$d" != ".git" ]]; then
            seen_dirs[$d]=1
            unique_dirs+=("$d")
        fi
    done

    echo "FILES:${unique_files[*]}"
    echo "DIRS:${unique_dirs[*]}"
}

# Get all worktrees as array of "path|branch" entries
get_worktrees() {
    git worktree list --porcelain | awk '
        /^worktree / { path = substr($0, 10) }
        /^branch / {
            branch = substr($0, 8)
            sub("refs/heads/", "", branch)
            print path "|" branch
        }
        /^HEAD / && !branch {
            # Detached HEAD - use commit
            print path "|" "(detached)"
        }
    '
}

# Find worktree path by branch name (supports partial matching)
find_worktree() {
    local search="$1"
    local exact_match=""
    local partial_matches=()

    while IFS='|' read -r path branch; do
        if [[ "$branch" == "$search" ]]; then
            exact_match="$path"
            break
        elif [[ "$branch" == *"$search"* ]]; then
            partial_matches+=("$path|$branch")
        fi
    done < <(get_worktrees)

    if [[ -n "$exact_match" ]]; then
        echo "$exact_match"
        return 0
    elif [[ ${#partial_matches[@]} -eq 1 ]]; then
        echo "${partial_matches[1]%%|*}"
        return 0
    elif [[ ${#partial_matches[@]} -gt 1 ]]; then
        print_err "${RED}Multiple worktrees match '$search':${NC}"
        for match in "${partial_matches[@]}"; do
            print_err "  ${match#*|} -> ${match%%|*}"
        done
        return 1
    else
        print_err "${RED}No worktree found matching '$search'${NC}"
        return 1
    fi
}

# Command: switch
cmd_switch() {
    local branch="$1"

    # Check if we're in a git repository
    if ! git rev-parse --show-toplevel &> /dev/null; then
        print_err "${RED}Not in a git repository${NC}"
        return 1
    fi

    # If no branch specified, use fzf for interactive selection
    if [[ -z "$branch" ]]; then
        if ! command -v fzf &> /dev/null; then
            print_err "${RED}No branch specified and fzf not installed${NC}"
            print_err "${YELLOW}Install fzf or specify a branch: wt switch <branch>${NC}"
            return 1
        fi

        local selection
        selection=$(get_worktrees | while IFS='|' read -r path branch; do
            # Get last commit info
            local commit_info=$(git -C "$path" log -1 --format="%ar|%s" 2>/dev/null | head -c 60)
            local time="${commit_info%%|*}"
            local msg="${commit_info#*|}"
            printf "%-30s ${DIM}%-15s %s${NC}\n" "$branch" "$time" "$msg"
        done | fzf --ansi --header="Select worktree" --preview-window=hidden)

        if [[ -z "$selection" ]]; then
            return 1
        fi
        branch="${selection%% *}"
    fi

    local worktree_path
    worktree_path=$(find_worktree "$branch")
    if [[ $? -ne 0 ]]; then
        return 1
    fi

    # Output special marker for shell integration to parse
    echo "__WT_CD__:$worktree_path"
}

# Command: remove
cmd_remove() {
    local branch=""
    local force=false
    local keep_branch=false
    local delete_remote=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force|-f)
                force=true
                shift
                ;;
            --keep-branch)
                keep_branch=true
                shift
                ;;
            --delete-remote)
                delete_remote=true
                shift
                ;;
            -*)
                print_color $RED "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$branch" ]]; then
                    branch="$1"
                else
                    print_color $RED "Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$branch" ]]; then
        print_color $RED "No branch specified"
        print_color $YELLOW "Usage: wt remove <branch> [--force] [--keep-branch] [--delete-remote]"
        return 1
    fi

    # Check if we're in a git repository
    if ! git rev-parse --show-toplevel &> /dev/null; then
        print_color $RED "Not in a git repository"
        return 1
    fi

    local project_dir=$(git rev-parse --show-toplevel)

    # Find the worktree
    local worktree_path
    worktree_path=$(find_worktree "$branch")
    if [[ $? -ne 0 ]]; then
        return 1
    fi

    # Get the actual branch name from the worktree
    local actual_branch=$(git -C "$worktree_path" rev-parse --abbrev-ref HEAD 2>/dev/null)

    # Check for uncommitted changes
    local dirty_status=$(git -C "$worktree_path" status --porcelain 2>/dev/null)
    if [[ -n "$dirty_status" ]]; then
        print_color $YELLOW "‚ö†Ô∏è  Worktree has uncommitted changes:"
        echo "$dirty_status" | head -10
        if [[ $(echo "$dirty_status" | wc -l) -gt 10 ]]; then
            echo "  ... and more"
        fi
        echo
        if [[ "$force" != true ]]; then
            print_color $RED "Use --force to remove anyway, or commit/stash changes first"
            return 1
        fi
    fi

    # Check if we're currently in this worktree
    local current_dir=$(pwd)
    if [[ "$current_dir" == "$worktree_path"* ]]; then
        print_color $RED "Cannot remove worktree you're currently in"
        print_color $YELLOW "Switch to another worktree first: wt switch main"
        return 1
    fi

    # Confirmation prompt
    if [[ "$force" != true ]]; then
        echo "About to remove:"
        echo "  Worktree: $worktree_path"
        echo "  Branch:   $actual_branch"
        if [[ "$delete_remote" == true ]]; then
            echo "  Remote:   origin/$actual_branch (will be deleted)"
        fi
        echo
        read -q "REPLY?Remove? [y/N] "
        echo
        if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
            print_color $YELLOW "Cancelled"
            return 1
        fi
    fi

    # Remove the worktree
    print_color $BLUE "Removing worktree..."
    if [[ -n "$dirty_status" ]]; then
        git worktree remove --force "$worktree_path"
    else
        git worktree remove "$worktree_path"
    fi

    if [[ $? -ne 0 ]]; then
        print_color $RED "Failed to remove worktree"
        return 1
    fi
    print_color $GREEN "‚úì Removed worktree: $worktree_path"

    # Delete local branch (unless --keep-branch)
    if [[ "$keep_branch" != true && "$actual_branch" != "main" && "$actual_branch" != "master" ]]; then
        print_color $BLUE "Deleting local branch..."
        git branch -D "$actual_branch" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            print_color $GREEN "‚úì Deleted local branch: $actual_branch"
        else
            print_color $YELLOW "‚ö† Could not delete local branch (may not exist or is checked out elsewhere)"
        fi
    fi

    # Delete remote branch if requested
    if [[ "$delete_remote" == true && "$actual_branch" != "main" && "$actual_branch" != "master" ]]; then
        print_color $BLUE "Deleting remote branch..."
        git push origin --delete "$actual_branch" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            print_color $GREEN "‚úì Deleted remote branch: origin/$actual_branch"
        else
            print_color $YELLOW "‚ö† Could not delete remote branch (may not exist)"
        fi
    fi

    print_color $GREEN "‚úÖ Done"
}

# Command: list
cmd_list() {
    # Check if we're in a git repository
    if ! git rev-parse --show-toplevel &> /dev/null; then
        print_color $RED "Not in a git repository"
        return 1
    fi

    local current_dir=$(pwd)

    echo
    printf "  ${CYAN}%-35s %-15s %-8s %s${NC}\n" "BRANCH" "LAST COMMIT" "STATUS" "PATH"
    echo "  $(printf '%.0s‚îÄ' {1..90})"

    get_worktrees | while IFS='|' read -r path branch; do
        # Check if this is the current worktree
        local marker="  "
        if [[ "$current_dir" == "$path"* ]]; then
            marker="${GREEN}‚Üí ${NC}"
        fi

        # Get last commit time
        local commit_time=$(git -C "$path" log -1 --format="%ar" 2>/dev/null)

        # Check for uncommitted changes
        local wt_status=""
        local git_status=$(git -C "$path" status --porcelain 2>/dev/null)
        if [[ -n "$git_status" ]]; then
            wt_status="${YELLOW}dirty${NC}"
        else
            wt_status="${GREEN}clean${NC}"
        fi

        # Shorten path for display
        local display_path="${path/#$HOME/~}"

        printf "${marker}%-35s %-15s %-8b %s\n" "$branch" "$commit_time" "$wt_status" "$display_path"
    done

    echo
}

# Command: new (create worktree)
cmd_new() {
    local branch_name=""
    local base_branch="$DEFAULT_BASE_BRANCH"
    local no_copy=false
    local no_cursor=true
    local use_symlinks=true
    local pr_number=""
    local is_remote=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --pr)
                if [[ -z "$2" ]]; then
                    print_color $RED "‚ùå --pr requires a PR number"
                    return 1
                fi
                pr_number="$2"
                shift 2
                ;;
            --no-copy)
                no_copy=true
                shift
                ;;
            --no-symlink)
                use_symlinks=false
                shift
                ;;
            --no-cursor)
                no_cursor=true
                shift
                ;;
            --cursor)
                no_cursor=false
                shift
                ;;
            -*)
                print_color $RED "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$branch_name" ]]; then
                    branch_name="$1"
                elif [[ "$base_branch" == "$DEFAULT_BASE_BRANCH" ]]; then
                    base_branch="$1"
                else
                    print_color $RED "Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Check if we're in a git repository
    if ! git rev-parse --show-toplevel &> /dev/null; then
        print_color $RED "‚ùå Not in a git repository"
        return 1
    fi

    # Get project directory and name
    local project_dir=$(git rev-parse --show-toplevel)
    local project_name=$(basename "$project_dir")

    # Handle PR checkout
    if [[ -n "$pr_number" ]]; then
        if ! command -v gh &> /dev/null; then
            print_color $RED "‚ùå GitHub CLI (gh) is not installed"
            print_color $YELLOW "   Install with: brew install gh"
            return 1
        fi

        print_color $BLUE "üîç Fetching PR #$pr_number..."

        # Get branch name from PR
        branch_name=$(gh pr view "$pr_number" --json headRefName -q .headRefName 2>/dev/null)
        if [[ -z "$branch_name" ]]; then
            print_color $RED "‚ùå Could not find PR #$pr_number"
            return 1
        fi

        print_color $GREEN "   Found branch: $branch_name"

        # Fetch the PR branch
        git fetch origin "$branch_name" &> /dev/null

        # Mark as remote branch
        is_remote=true
    fi

    # Validate branch name
    if [[ -z "$branch_name" ]]; then
        print_color $RED "‚ùå No branch name provided"
        show_usage
        return 1
    fi

    # Define worktree paths
    local worktree_parent="${project_dir}/../${project_name}-worktrees"

    # Strip origin/ prefix for directory name if present
    local dir_name="${branch_name#origin/}"
    local worktree_path="${worktree_parent}/${dir_name}"

    # Create parent directory
    mkdir -p "$worktree_parent"

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        print_color $RED "‚ùå Worktree already exists at: $worktree_path"
        return 1
    fi

    # Create the worktree based on branch type
    if [[ "$branch_name" =~ ^origin/ ]]; then
        # Explicit remote branch (e.g., origin/OCT-12345)
        local remote_branch="$branch_name"
        local local_branch="${branch_name#origin/}"

        # Fetch latest
        print_color $BLUE "üåê Fetching latest from origin..."
        git fetch origin &> /dev/null

        if ! git show-ref --verify --quiet "refs/remotes/$remote_branch"; then
            print_color $RED "‚ùå Remote branch '$remote_branch' does not exist"
            return 1
        fi

        print_color $BLUE "üåê Checking out remote branch '$remote_branch'..."
        git -C "$project_dir" worktree add "$worktree_path" "$remote_branch"

        # Create local tracking branch
        cd "$worktree_path"
        git checkout -b "$local_branch" --track "$remote_branch" &> /dev/null
        cd - > /dev/null

        print_color $GREEN "   Tracking branch '$local_branch' -> '$remote_branch'"

    elif [[ "$is_remote" == true ]] || git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
        # Auto-detected remote branch or PR branch
        if [[ "$is_remote" != true ]]; then
            print_color $BLUE "üåê Found '$branch_name' on remote..."
            git fetch origin &> /dev/null
        fi

        print_color $BLUE "üåê Creating worktree from remote branch..."
        git -C "$project_dir" worktree add "$worktree_path" "origin/$branch_name"

        # Create local tracking branch
        cd "$worktree_path"
        git checkout -b "$branch_name" --track "origin/$branch_name" &> /dev/null
        cd - > /dev/null

        print_color $GREEN "   Tracking branch '$branch_name' -> 'origin/$branch_name'"

    elif git show-ref --verify --quiet "refs/heads/$branch_name"; then
        # Existing local branch
        print_color $BLUE "üîÑ Branch '$branch_name' already exists locally, creating worktree..."
        git -C "$project_dir" worktree add "$worktree_path" "$branch_name"

    else
        # New branch
        if ! git show-ref --verify --quiet "refs/heads/$base_branch"; then
            print_color $RED "‚ùå Base branch '$base_branch' does not exist"
            return 1
        fi
        print_color $BLUE "üåø Creating new branch '$branch_name' from '$base_branch'..."
        git -C "$project_dir" worktree add -b "$branch_name" "$worktree_path" "$base_branch"
    fi

    # Copy files if not disabled
    if [[ "$no_copy" != true ]]; then
        local copy_result=$(get_files_to_copy)
        local files_line=$(echo "$copy_result" | grep "^FILES:")
        local dirs_line=$(echo "$copy_result" | grep "^DIRS:")

        IFS=' ' read -A copy_files <<< "${files_line#FILES:}"
        IFS=' ' read -A copy_dirs <<< "${dirs_line#DIRS:}"

        # Copy files (exclude .git)
        for file in "${copy_files[@]}"; do
            if [[ -n "$file" && "$file" != ".git" && -f "$project_dir/$file" ]]; then
                cp "$project_dir/$file" "$worktree_path/$file"
                print_color $GREEN "üìÑ Copied $file"
            fi
        done

        # Handle directories - symlink editor configs, copy others
        for dir in "${copy_dirs[@]}"; do
            if [[ -n "$dir" && "$dir" != ".git" && -d "$project_dir/$dir" ]]; then
                local target_dir="$worktree_path/$(dirname "$dir")"
                mkdir -p "$target_dir"

                # Symlink editor configs for efficiency, copy others
                if [[ "$use_symlinks" == true ]] && [[ "$dir" =~ ^\.(vscode|claude|cursor|idea|fleet|zed|nova|sublime)$ ]]; then
                    ln -s "$project_dir/$dir" "$worktree_path/$dir"
                    print_color $GREEN "üîó Symlinked $dir"
                else
                    cp -R "$project_dir/$dir" "$target_dir/"
                    print_color $GREEN "üìÅ Copied $dir"
                fi
            fi
        done

        # Symlink node_modules if it exists (huge space/time saver)
        if [[ -d "$project_dir/node_modules" ]]; then
            print_color $YELLOW "üì¶ Symlinking node_modules from main repo..."
            ln -s "$project_dir/node_modules" "$worktree_path/node_modules"
            print_color $GREEN "   üîó Symlinked (read-only). Remove symlink to install different deps."
        fi
    fi

    # Create logs directory and touch development.log
    mkdir -p "$worktree_path/logs"
    touch "$worktree_path/logs/development.log"
    print_color $GREEN "üìù Created logs/development.log"

    # Run direnv allow && mise trust
    if command -v direnv &> /dev/null && command -v mise &> /dev/null; then
        cd "$worktree_path"
        direnv allow &> /dev/null && mise trust &> /dev/null
        print_color $GREEN "üîß Ran direnv allow && mise trust"
        cd - > /dev/null
    fi

    # Open in Cursor if not disabled
    if [[ "$no_cursor" != true ]] && command -v cursor &> /dev/null; then
        cursor "$worktree_path" &> /dev/null &
        print_color $GREEN "üöÄ Opening in Cursor..."
    fi

    # Success message
    print_color $GREEN "‚úÖ Worktree '$dir_name' created at:"
    print_color $GREEN "   $worktree_path"
}

# Main entry point
main() {
    # Handle global options first
    case "${1:-}" in
        -h|--help)
            show_usage
            return 0
            ;;
        -v|--version)
            echo "wt version $VERSION"
            return 0
            ;;
        --shell-init)
            shell_init
            return 0
            ;;
    esac

    # Dispatch to subcommands
    local cmd="${1:-}"

    case "$cmd" in
        new)
            shift
            cmd_new "$@"
            ;;
        switch)
            shift
            cmd_switch "$@"
            ;;
        remove|rm)
            shift
            cmd_remove "$@"
            ;;
        list|ls|--list)
            cmd_list
            ;;
        "")
            show_usage
            return 1
            ;;
        -*)
            # Unknown option
            print_color $RED "Unknown option: $cmd"
            show_usage
            return 1
            ;;
        *)
            # Default: treat as branch name for 'new' command (backwards compatibility)
            cmd_new "$@"
            ;;
    esac
}

# Run main function
main "$@"
